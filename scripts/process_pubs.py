import os
import re
import sys

SPECIAL_KEYS = ["webpage", "url", "talk", "video"]


def get_citation_strings(bib_data):
    # Create an empty dictionary to store the content of the @STRING declarations
    venues = {}

    # Regex pattern for string declarations. The pattern captures two groups: the key and the value.
    pattern = r"@STRING{([^\s*=]+)\s*=\s*({.*})}"

    # Use re.findall() to find all non-overlapping matches of the pattern in the file content
    matches = re.findall(pattern, bib_data, flags=re.MULTILINE)

    # Populate the dictionary with matches
    for key, value in matches:
        venues[key] = value.strip()

    # Now venues contains the content of @STRING declarations.
    return venues


def find_citation(key, bib_data):
    # Define regex pattern to extract the bibtex entry, using lazy quantifier to stop at the first closing brace
    bibtex_entry_pattern = r'@[a-zA-Z]+{' + re.escape(key) + r',.*?^\}'

    # Search for the pattern in the bibtex_content using MULTILINE flag to match start of each line
    match = re.search(bibtex_entry_pattern, bib_data, re.DOTALL | re.MULTILINE)

    if not match:
        print(f"No bibtex entry found with key '{key}'.")
        return ""

    citation = match.group(0)
    return citation


def format_citation(citation, venue_strings):
    citation = citation.split("\n")

    new_lines = []
    for line in citation:
        # If any strings are used, replace them. TODO: test.
        for bib_str in venue_strings.keys():
            if bib_str in line:
                line = line.replace(bib_str, venue_strings[bib_str])
        # if line.strip().startswith("booktitle") or line.strip().startswith("journal"):
        #     venue = line.split("=")[1].strip().replace(",", "")
        #     if venue in venue_strings.keys():
        #         line = line.replace(venue, venue_strings[venue])

        # Don't add any lines that correspond to special keys.
        is_special = any([line.strip().startswith(k) for k in SPECIAL_KEYS])
        if not is_special:
            new_lines.append(line)

    # Check if the last line ends with a comma.
    if new_lines[-2].endswith(","):
        new_lines[-2] = new_lines[-2].replace(",", "")

    # Put the citation back together as one string.
    citation = '\n'.join(new_lines)

    return citation


def format_entries(data, bib_data):
    venues = get_citation_strings(bib_data)
    modified_data = data[:]

    # Grab all inner content.
    for ele in re.findall(r'<p><a name="(.*?)</p>', data, flags=re.DOTALL):
        tag = ele.split('"></a>')[0]  # This grabs just the tag of the citation.
        orig = '</a>'.join(ele.split('</a>')[1:]).strip()

        # Get title and authors.
        ele = orig.split('.\n')
        authors, title = ele[:2]
        # Bold the title and add a line break.
        title = "<b>" + title.strip() + "</b><br/>"
        # Swap title and authors.
        ele[0] = title
        ele[1] = authors.strip() + "<br/>"  # Add line break after authors.

        ele = '.\n'.join(ele)
        # In adding line breaks, some breaks were inserted before the period. Move periods before breaks.
        ele = re.sub(r'<br/>\s*?.', '.<br/>', ele, flags=re.DOTALL)

        # Grab the bibtex and add it to the end of the entry.
        citation = find_citation(tag, bib_data)
        if len(citation) > 0:
            citation = format_citation(citation, venues)
            # Add the button to click.
            button = f'&nbsp;&nbsp;<a data-target="#{tag}"> <i class="fa-solid fa-quote-right"></i>&nbsp;&nbsp;Bibtex </a>'
            citation_div = f"<div id=\"{tag}\" class=\"bibtex hidden\">\n<pre>{citation}</pre>\n</div>"
            ele = "\n".join([ele, button, citation_div])
        else:
            print(f"WARN: No bibtex for entry {tag}")

        modified_data = modified_data.replace(orig, ele)

    return modified_data


def process_html(data, bib_data):
    # Remove the "generated by" message.
    position = data.find("<hr>")
    if position != -1:
        data = data[:position]

    # Split the content into lines
    lines = data.split('\n')

    # Apply the substitutions to each line
    modified_lines = []
    for line in lines:
        # Remove leading '['
        line = re.sub(r'^\[&nbsp;', '', line)
        # Remove trailing ']'
        line = re.sub(r'&nbsp;\]$', '', line)
        # Remove trailing '| '
        line = re.sub(r'\|\s*$', '&nbsp;', line)
        modified_lines.append(line)

    # Join the modified lines back into a single string
    data = '\n'.join(modified_lines)

    # Swap title and authors.
    data = format_entries(data, bib_data)
    # Highlight my name.
    data = re.sub(r"Jana\s*Pavlasek", "<span class=\"me\">Jana Pavlasek</span>", data, flags=re.DOTALL)

    return data


if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("Provide the path to the HTML and BIB file.")
        exit(-1)

    html_path = sys.argv[1]
    if not os.path.exists(html_path):
        print("File does not exist:", html_path)
        exit(-1)

    # Grab the bib file for citation keys.
    bib_path = sys.argv[2]
    if not os.path.exists(bib_path):
        print("Bib file does not exist:", bib_path)
        exit(-1)

    with open(html_path, 'r') as f:
        data = ''.join(f.readlines())

    with open(bib_path, 'r') as f:
        bib_data = ''.join(f.readlines())

    data = process_html(data, bib_data)

    with open(html_path, 'w') as f:
        f.write(data)
